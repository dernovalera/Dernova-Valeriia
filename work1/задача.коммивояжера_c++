#include <Windows.h>  // подключаем библиотеку для русского языка
#include <iostream>  // для ввода и вывода данных
#include <vector>  // подключаем библиотеку для использования динамического массива
#include <algorithm>  // функция, которая перебирает все возможные комбинации (перестановки)
using namespace std;  // чтобы не писать std:: перед cin (вводит пользователь) и cout (выводит компьютер)

int main() {
    SetConsoleCP(65001);  // чтобы вводить на русском языке
    SetConsoleOutputCP(65001);  // чтобы выводить на русском языке
    int n;  // n - количество городов
    cout << "Введите количество городов: ";
    cin >> n;  // пользователь вводит число, это число "присваивается" n

    vector<vector<int>> dist(n, vector<int>(n));  // создаем матрицу расстояний, расстояние от города i до города j
    cout << "Введите матрицу расстояний (" << n << "x" << n << "):\n";
    for (int i = 0; i < n; i++) {  // цикл по строкам матрицы
        for (int j = 0; j < n; j++) {  // цикл по столбцам матрицы
            cin >> dist[i][j];  // цикл заполняет матрицу dist числами, введёнными пользователем
        }
    }
    vector<int> cities;  // создаем пустой вектор целых чисел, в нём будут храниться города
    for (int i = 1; i < n; i++) {  // перебирает все города (исключая стартовый)
        cities.push_back(i);  // добавляет число i в конец вектора (формируем список городов, чтобы потом перебирать все маршруты)
    }

    int min_cost = 1000000000;    // минимальна сумма расстояний, начинаем с большого числа
    vector<int> best_path; // сюда сохраним маршрут с минимальной суммой расстояний

    do {  // начинаем цикл, который перебирает все перестановки cities
        int current_cost = 0;
        int current_city = 0; // начинаем с города 0

        for (int next_city : cities) {  // перебирает каждый город
            current_cost += dist[current_city][next_city];  // прибавляем к current_cost расстояние между городом, в которым находимся сейчас и куда идём
            current_city = next_city;  // текущим становится город, в который перешли
        }

        current_cost += dist[current_city][0];  // после обхода всех городов возвращаемся в начальный город 0

        if (current_cost < min_cost) {  // проверяем, нашелся ли маршрут с меньшим расстоянием, чем все предыдущие
            min_cost = current_cost;  // если да, то сохраняем
            best_path = cities;  //  созраняем этот маршрут как лучший
        }

    } while (next_permutation(cities.begin(), cities.end()));  // проверка каждого возможного маршрута (перебор всех вариантов)

    cout << "\nМинимальная стоимость маршрута: " << min_cost << endl;  // минимальный маршрут
    cout << "Оптимальный маршрут: 0 -> ";  // сам маршрут
    for (int city : best_path) {  // показывает последовательность городов маршрута
        cout << city << " -> ";  // для каждого города выводит его номер и стрелку
    }
    cout << "0\n";  //возвращает в старт (полный цикл)

    return 0;
}
