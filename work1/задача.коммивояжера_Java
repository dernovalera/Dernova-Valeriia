import java.util.Scanner;  // подключаем класс, чтобы считывать данные с клавиатуры

public class Main {
    static int n;  // количество городов
    static int[][] dist;  // расстояние между городами
    static boolean[] visited;  // отмечает посещенные города (true = город посещен)
    static int minCost = Integer.MAX_VALUE;  // минимальная сумма расстояний среди всех маршрутов
    static int[] bestPath;   // в этом массиве сохраняем оптимальный маршрут

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);  // считываем ввод с клавиатуры
        System.out.print("Введите количество городов: ");  // выводим сообщение
        n = sc.nextInt();  // считываем число и сохраняем его в n

        dist = new int[n][n];  // создаем матрицу n x n, чтобы хранить расстояния между городами
        System.out.println("Введите матрицу расстояний:");  // выводим сообщение
        for (int i = 0; i < n; i++)  // цикл по строкам матрицы
            for (int j = 0; j < n; j++)  //  цикл по столбцам матрицы
                dist[i][j] = sc.nextInt();  // заполняем матрицу расстояний числами, которые ввел пользователь

        visited = new boolean[n];  // создаем массив для отслеживания посещенных городов
        visited[0] = true;  // город 0 отмечаем как посещенный, так как начинаем маршрут с него

        int[] path = new int[n]; // создаем массив для хранения текущего маршрута во время рекурсии
        path[0] = 0;   // первый город - стартовый город 0
        bestPath = new int[n];  // массив для хранения лучшего маршрута

        tsp(0, 1, 0, path);  // вызываем рекурсивную функцию tsp: 0 - текущий (стартовый) город, 1 - уже посещен один город (0), 0 - сумма расстояний пройденного маршрута, path - массив текущего маршрута

        System.out.println("Минимальная сумма расстояний: " + minCost);  // выводим минимальную сумму расстояний
        System.out.print("Оптимальный маршрут: ");  // выводим оптимальный маршрут
        for (int i = 0; i < n; i++) {  // перебираем все города в оптимальном маршруте
            System.out.print(bestPath[i] + " -> ");  // выводим номер текущего города со стрелкой (проходим по массиву bestPath)
        }
        System.out.println("0");  // завершаем маршрут в стартовом городе
    }

    static void tsp(int currentCity, int count, int costSoFar, int[] path) {  // рекурсивная функция для перебора всех маршрутов (currentCity — текущий город, count — сколько городов уже включено в маршрут, costSoFar — сумма расстояний до текущего момента, path — массив текущего маршрута)
        if (count == n) {  // если все города посещены
            costSoFar += dist[currentCity][0]; // добавляем расстояние от последнего города обратно в стартовый
            if (costSoFar < minCost) {  // если текущий маршрут лучше предыдущего (меньше)
                minCost = costSoFar;  // сохраняем сумму
                System.arraycopy(path, 0, bestPath, 0, n); // сохраняем маршрут в bestPath
            }
            return;
        }

        for (int nextCity = 0; nextCity < n; nextCity++) {  // перебираем все города
            if (!visited[nextCity]) { // если город не посещен - рассматриваем его как следующий
                visited[nextCity] = true;  // отмечаем как посещенный
                path[count] = nextCity; // добавляем в маршрут
                tsp(nextCity, count + 1, costSoFar + dist[currentCity][nextCity], path);  // идем в следующий город, увеличиваем количество посещенных городов и прибавляем расстояние до него
                visited[nextCity] = false; // отменяем пометку города как посещённого (backtracking), чтобы другие маршруты могли его использовать
            }
        }
    }
}
