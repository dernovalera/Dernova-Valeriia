#include <Windows.h>  // подключаем библиотеку для русского языка
#include <iostream>  // для ввода и вывода данных
#include <vector>  // Подключаем библиотеку для использования динамического массива
using namespace std;  // чтобы не писать std:: перед cin (вводит пользователь) и cout (выводит компьютер)

int main() {
    vector<int> heap;// это массив, который может менять размер во время работы программы, а heap - контейнер для бинарной кучи
    SetConsoleCP(65001);  // чтобы вводить на русском языке
    SetConsoleOutputCP(65001);  // чтобы выводить на русском языке
    // вставка элемента
    auto insert = [&](int value){  // вставляем число value в кучу
        heap.push_back(value);  // добавляем элемент в конец
        int i = heap.size() - 1;   // i - индекс только что добавленного элемента
        while(i > 0 && heap[i] > heap[(i-1)/2]) {  // проверяем, что элемент не является корнем (корень имеет индекс 0) и больше ли он родителя
            swap(heap[i], heap[(i-1)/2]);  // меняем местами если да (родитель меньше)
            i = (i-1)/2;  // переходим к родителю и снова проверяем
        }
    };

    // извлечение максимального элемента
    auto extractMax = [&](){
        if(heap.empty()) return -1;  // если куча пустая, возвращаем -1
        int maxVal = heap[0];  // максимальный элемент всегда в корне (heap[0])
        heap[0] = heap.back();  // заменяем корень последним элементом
        heap.pop_back();  // удаляем последний элемент, который теперь в корне

        int i = 0;  // начинаем с корня, поэтому i = 0
        while(true) {  // запускаем цикл, который будет опускать элементы, пока он не окажется на нужной позиции
            int left = 2*i + 1;  // индекс левого ребенка
            int right = 2*i + 2;  // индекс правого ребенка
            int largest = i;  // пока считаем, что наибольший — это текущий элемент

            if(left < heap.size() && heap[left] > heap[largest]) largest = left;  // проверяем левого ребенка, существует ли он, если он больше, то запоминаем его индекс как largest
            if(right < heap.size() && heap[right] > heap[largest]) largest = right;  // проверяем правого ребенка, существует ли он, если он больше, то запоминаем его индекс как largest
            if(largest == i) break;  // если ни один ребёнок не больше текущего, останавливаемся

            swap(heap[i], heap[largest]);  // элемент опускается вниз, пока не станет больше своих детей
            i = largest;  // продолжаем процесс опускания вниз
        }

        return maxVal;  // возвращаем максимальный элемент
    };
    // добавляем элементы в кучу
    insert(10);
    insert(20);
    insert(5);
    insert(13);
    insert(28);

    cout << "Max: " << extractMax() << "\n"; // выводим максимум (корень кучи), он удаляется, на его места встает последний элемент массива, который будет опускаться вниз, пока не окажется на своем месте, "\n" — это символ новой строки
    cout << "Heap now: ";  
    for(int x : heap) cout << x << " ";  // каждый элемент из heap по очереди печатаем (остальные элементы кучи)
}
